#ifndef _QALGORITHMS_QBIN_INCLUDED
#define _QALGORITHMS_QBIN_INCLUDED

#include <vector>
#include <string>

#include "qalgorithms_datatypes.h"

namespace qAlgorithms
{
    // ####################################################################################################### //

    /// @brief wrapper function to execute qbinning on a std::vector<CentroidPeak> struct
    /// @param centroidedData centroid vector generated by qPeaks.passToBinning(...), defined in qalgorithms_qpeaks.cpp
    /// @param convertRT vector containing the retention time for every scan number
    /// @param verbose if this option is selected, additional progress report is written to standard out
    /// @return returns the centroids as a collection of vectors
    std::vector<EIC> performQbinning_old(const std::vector<CentroidPeak> *centroidedData,
                                         const std::vector<unsigned int> *convertRT);

    // ###################################################################################################### //
#pragma region "utility"

    /// @brief calculate the mean distance in mz to all other close elements of a sorted vector for one element
    /// @param pointsInBin vector of data points sorted by scans
    /// @return vector of the mean inner distances for all elements in the same order as pointsInBin
    std::vector<float> meanDistanceRegional(const std::vector<const CentroidPeak *> *pointsInBin,
                                            const size_t expandedDist);

    /// @brief calculate the data quality score as described by Reuschenbach et al. for one datapoint in a bin
    /// @param MID mean inner distance in mz to all other elements in the bin
    /// @param MOD minimum outer distance - the shortest distance in mz to a data point that is within maxdist and not in the bin
    /// @return the data quality score for the specified element
    inline float calcDQS(const float MID, const float MOD); // Mean Inner Distance, Minimum Outer Distance

#pragma endregion "utility"

#pragma region "Bin"

    // Bin Class
    class Bin
    {
    public:
        std::vector<const CentroidPeak *> pointsInBin;
        std::vector<float> DQSB_base;   // DQSB when all distances are considered equal @todo remove this eventually
        std::vector<float> DQSB_scaled; // DQSB if a gaussian falloff is assumed

        float mzMin = -1;
        float mzMax = -1;
        unsigned int scanMin = -1;
        unsigned int scanMax = -1;
        float medianMZ = -1; // only used for removing duplicates

        bool unchanged = false;     // if this is true after every test has run once, the bin is viable
        bool duplicateScan = false; // are two points with the same scan number in this bin?
        bool l_maxdist_tooclose = false;
        bool r_maxdist_tooclose = false; // Check if there is a point within maxdist

        /// @brief generate a bin that is a subset of an existing bin using two iterators.
        /// @details since this extracts a continuous sequence, it is only a good idea
        /// to construct a new bin like this after a completed subsetting step.
        /// @param startBin left border of the new bin
        /// @param endBin right border of the new bin
        Bin(const std::vector<const CentroidPeak *>::iterator &binStartInOS, const std::vector<const CentroidPeak *>::iterator &binEndInOS);

        Bin();

        void subsetScan(std::vector<Bin> *bincontainer, std::vector<const CentroidPeak *> *notInBins);

        // returns the start index of where in the sorted not-binned points the minimum start position is
        size_t makeDQSB(const std::vector<const CentroidPeak *> *notInBins, size_t idx_lowerLimit);

        EIC createEIC(const std::vector<unsigned int> *convertRT);
    };

    std::vector<Bin> performQbinning(const std::vector<CentroidPeak> *centroids);

    Bin makeBin_scan(const std::vector<const CentroidPeak *> *centroids, const size_t binStartPos, const size_t binEndPos);

    Bin makeBin_mz(const std::vector<const CentroidPeak *> *const centroids, const Range_i *range);

    const std::vector<double> makeOrderSpace(const Bin *bin);

    const std::vector<double> makeCumError(const std::vector<const CentroidPeak *> *bin);

    // returns number of elements added to the stack?
    int subsetMZ_stack(std::vector<Range_i> *stack,
                       std::vector<Bin> *bincontainer,
                       std::vector<const CentroidPeak *> *notInBins,
                       const std::vector<const qAlgorithms::CentroidPeak *> *pointsInSourceBin,
                       const std::vector<double> *OS,
                       const std::vector<double> *cumError);

    bool binLimitsOK(Bin sourceBin, const std::vector<CentroidPeak> *rawdata);

    // every index at bin stage is the "original" index of the MS1 spectrum.
    // they need to be converted to the corrected scan index which accounts for
    // interpolation.
    EIC binToEIC(const Bin *sourceBin, const std::vector<unsigned int> *convertIndex);

    void interpolateEIC(EIC *eic);

#pragma endregion "Bin"

#pragma region "Bin Container"
    // BinContainer
    struct BinContainer
    {
        std::vector<Bin> processBinsF;               // bin target in the starting case
        std::vector<Bin> processBinsT;               // bin target one past the starting case
        std::vector<Bin> viableBins;                 // only includes bins which cannot be further subdivided
        std::vector<Bin> finalBins;                  // bins which have been confirmed to not include incorrect binning
        std::vector<const CentroidPeak *> notInBins; // this vector contains all points which are not included in bins
        bool readFrom = false;
        // pointers for use during subsetting loop
        std::vector<Bin> *sourceBins;
        std::vector<Bin> *targetBins;
    };

    void switchTarget(BinContainer *bincontainer);

    void subsetBins(BinContainer &bincontainer);

    // remove points with duplicate scans from a bin by choosing the one closest to the median
    void deduplicateBin(std::vector<Bin> *target, std::vector<const CentroidPeak *> *notInBins, Bin bin);

#pragma endregion "Bin Container"

    bool massTraceStable(std::vector<float> massesBin, int idxStart, int idxEnd);
}

#endif